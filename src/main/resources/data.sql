insert into users(user_id, create_date, introduce, admin_flag, password, user_rank) values('testid', current_timestamp(), 'hi hello', 0,'testpw', 5);
insert into users(user_id, create_date, introduce, admin_flag, password, user_rank) values('slygun', current_timestamp(), 'dk', 0, '1', 	105550);
insert into users(user_id, create_date, introduce, admin_flag, password, user_rank) values('omh9876',current_timestamp(), '오민혁2020114618', 0, '2', 6392);
insert into users(user_id, create_date, introduce, admin_flag, password, user_rank) values('fantasy7772',current_timestamp(), '김진욱', 0, '3', 11780);
insert into users(user_id, create_date, introduce, admin_flag, password, user_rank) values('nickse461',current_timestamp(), '안녕하세요', 0, '4', 56715);
insert into users(user_id, create_date, introduce, admin_flag, password, user_rank) values('pppp1923',current_timestamp(), '123456', 0, '5', 2621);

insert into problems(problem_id, problem_title, problem_content, input_condition, output_condition, problem_rank) values (21920, '서로소 평균', '효성이는 길이가 N인 수열 A에서 X와 서로소인 수들을 골라 평균을 구해보려고 한다. 효성이를 도와 이를 계산해주자.', '첫 번째 줄에 입력될 수들의 개수 N이 주어진다(N은 2이상 500,000이하). 두번째 줄에는 수열 A를 이루는 자연수 Ai가 공백과 함께 주어진다(Ai는 2이상 1,000,000이하). 수열 A에 X와 서로소인 수가 최소 1개 이상 존재한다. 마지막 줄에는 X가 주어진다(X는 2이상 1,000,000이하).' , '첫째 줄에 수열 A에서 X와 서로소인 수들의 평균을 출력한다. 절대/상대 오차는 1/1,000,000까지 허용한다.', 43234);
insert into problems(problem_id, problem_title, problem_content, input_condition, output_condition, problem_rank) values (21919, '소수 최소 공배수', '행복이는 길이가 N인 수열 A에서 소수들을 골라 최소공배수를 구해보려고 한다. 행복이르 도와 이를 계산해주자.', '첫째 줄에 수열 A의 길이 N이 주어진다(N은 1이상 10,000이하). 그 다음줄에는 수열 A의 원소 Ai가 공백과 함께 주어진다(Ai는 2이상 1,000,000이하). 답이 2^64 미만인 입력만 주어진다.', '첫째 줄에 소수들의 최소공배수를 출력한다. 만약 소수가 없는 경우는 -1을 출력한다.', 43233);
insert into problems(problem_id, problem_title, problem_content, input_condition, output_condition, problem_rank) values (21921, '블로그', '찬솔이는 블로그를 시작한 지 벌써 N일이 지났다. 요즘 바빠서 관리를 못 했다가 방문 기록을 봤더니 벌써 누적 방문 수가 6만을 넘었다. 찬솔이는 X일 동안 가장 많이 들어온 방문자 수와 그 기간들을 알고 싶다. 찬솔이를 대신해서 X일 동안 가장 많이 들어온 방문자 수와 기간이 몇 개 있는지 구해주자.', '첫째 줄에 블로그를 시작하고 지난 일수 N과 X가 공백과 함께 주어진다. 둘째 줄에는 블로그 시작 1일차부터 N일차까지 하루 방문자 수가 공백과 함께 주어진다.', '첫째 줄에 X일 동안 가장 많이 들어온 방문자 수를 출력한다. 만약 최대 방문자 수가 0명이라면 SAD를 출력한다. 만약 최대 방문자 수가 0명이 아닌 경우 둘째 줄에 기간이 몇 개 있는지 출력한다.', 43235);
insert into problems(problem_id, problem_title, problem_content, input_condition, output_condition, problem_rank) values (21567, '슷자의 개수2', '세 개의 자연수 A,B,C가 주어질 때  A × B × C를 계산한 결과에 0부터 9까지 각각의 숫자가 몇 번씩 쓰였는지를 구하는 프로그램을 작성하시오. 예를 들어 A = 150, B = 266, C = 427 이라면 A × B × C = 150 × 266 × 427 = 17037300 이 되고, 계산한 결과 17037300 에는 0이 3번, 1이 1번, 3이 2번, 7이 2번 쓰였다.', '첫째 줄에 A, 둘째 줄에 B, 셋째 줄에 C가 주어진다. A, B, C는 모두 1,000,000보다 작은 자연수이다.', '첫째 줄에는 A × B × C의 결과에 0 이 몇 번 쓰였는지 출력한다. 마찬가지로 둘째 줄부터 열 번째 줄까지 A × B × C의 결과에 1부터 9까지의 숫자가 각각 몇 번 쓰였는지 차례로 한 줄에 하나씩 출력한다.', 43112);
insert into problems(problem_id, problem_title, problem_content, input_condition, output_condition, problem_rank) values (21294, '와 쿼리', '이때, 다음 쿼리를 수행하는 프로그램을 작성하시오. * 1: 업데이트한다. *2: 출력한다.', '첫째 줄에 쿼리의 개수 Q가 주어진다(Q는 1이상 1,000,000이하). 둘째 줄부터 Q개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.', '각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.', 40138);
insert into problems(problem_id, problem_title, problem_content, input_condition, output_condition, problem_rank) values (20946, '합성인수분해', '소인수분해란 어떤 자연수를 소수의 곱으로 나타내는 것이다. 정수론을 끔찍하게 싫어하는 연두는 소수만 보면 치가 떨려, 대신에 자연수를 합성수의 곱으로 나타내는 “합성인수분해”라는 것을 만들었다. 자연수 N의 합성인수분해는 다음의 조건을 모두 만족하는 수열 A로 정의한다. * A의 모든 원소는 합성수이다. (합성수란 1과 자기 자신 이외의 다른 약수를 가지는 정수이다.) * A의 모든 원소의 곱은 N이다. 하지만 연두는 N의 합성인수분해가 여러 개이거나 존재하지 않을 수도 있다는 것을 깨달았다. 연두를 대신해 N을 합성인수분해 해주는 프로그램을 만들어보자. 만약 가능한 결과가 여러 개일 경우, 사전 순으로 가장 앞서는 것을 선택해야 한다.', 'N', 'N의 합성인수분해 중 사전순으로 가장 앞서는 수열의 원소들을 순서대로 공백으로 구분하여 출력한다. 합성인수분해가 불가능하다면 대신에 -1을 출력한다.', 39216);
insert into problems(problem_id, problem_title, problem_content, input_condition, output_condition, problem_rank) values (21276, '계보 복원가 호석', '석호촌에는 N 명의 사람이 살고 있다. 굉장히 활발한 성격인 석호촌 사람들은 옆 집 상도 아버님, 뒷집 하은 할머님 , 강 건너 유리 어머님 등 모두가 한 가족처럼 살아가고 있다. 그러던 어느 날, 유구한 역사를 지닌 석호촌의 도서관에 화재가 나서 계보들이 모두 불타고 말았다. 그래도 계보는 있어야 하지 않겠느냐는 마을 어르신인 대일 촌장님의 의견에 따라 석호촌 사람들은 계보 복원가 호석에게 의뢰를 맡기기로 했다. 적어도 현재를 함께 살아가는 N 명의 계보는 복원하고 싶은 호석이는 조사를 통해서 각자가 기억하는 조상들의 이름들을 구해냈다. 다행히도 석호촌의 맑은 정기 덕분에 기억력이 굉장히 좋은 주민들은 모든 조상을 완벽하게 기억하고 있다. 또한, 각 가문은 한 명의 시조를 root로 하는 트리 형태를 띈다는 것도 알아냈다. 이 때 "조상"이란, "자신의 부모"와 "부모의 조상"을 모두 합친 것을 의미한다. 이를 기반으로 몇 개의 가문이 존재했는 지, 각 가문에 대한 정보를 출력하는 프로그램을 작성해서 호석이를 도와주자!', '첫번째 줄에 석호촌에 살고 있는 사람의 수 N 이 주어진다. 두번째 줄에는 현재 살고 있는 사람들의 이름이 차례대로 주어진다. 모든 이름은 길이 1 이상 6 이하의 알파벳 소문자로 이뤄지며, 중복된 이름은 존재하지 않는다. 세번째 줄에는 기억하는 정보의 개수 M 이 주어진다. 이어지는 M개의 줄에는 "X Y" 꼴로 기억들이 주어지는데, 이는 곧 X의 조상 중에 Y가 있다는 것을 의미하며 같은 정보가 중복되어 주어지지 않는다. 입력에 모순이 있는 경우는 주어지지 않는다.', '첫번째 줄에는 가문의 개수 K 를 출력하라. 두 번째 줄에는 각 가문의 시조들의 이름을 공백으로 구분하여 사전순으로 출력하라. 세번째 줄부터는 이름의 사전순 대로 사람의 이름과 자식의 수, 그리고 사전순으로 자식들의 이름을 공백으로 구분하여 출력하라.', 47883);
insert into problems(problem_id, problem_title, problem_content, input_condition, output_condition, multilingual_flag, problem_rank) values (8958, 'OX퀴즈', '"OOXXOXXOOO"와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다. "OOXXOXXOOO"의 점수는 1+2+0+0+1+0+0+1+2+3 = 10점이다. OX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.', '첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 길이가 0보다 크고 80보다 작은 문자열이 주어진다. 문자열은 O와 X만으로 이루어져 있다.', '각 테스트 케이스마다 점수를 출력한다.', 1, 38989);
insert into problems(problem_id, problem_title, problem_content, input_condition, output_condition, multilingual_flag, problem_rank) values (17626, 'Four Squares', '라그랑주는 1770년에 모든 자연수는 넷 혹은 그 이하의 제곱수의 합으로 표현할 수 있다고 증명하였다. 어떤 자연수는 복수의 방법으로 표현된다. 예를 들면, 26은 52과 12의 합이다; 또한 42 + 32 + 12으로 표현할 수도 있다. 역사적으로 암산의 명수들에게 공통적으로 주어지는 문제가 바로 자연수를 넷 혹은 그 이하의 제곱수 합으로 나타내라는 것이었다. 1900년대 초반에 한 암산가가 15663 = 1252 + 62 + 12 + 12라는 해를 구하는데 8초가 걸렸다는 보고가 있다. 좀 더 어려운 문제에 대해서는 56초가 걸렸다: 11339 = 1052 + 152 + 82 + 52. 자연수 n이 주어질 때, n을 최소 개수의 제곱수 합으로 표현하는 컴퓨터 프로그램을 작성하시오.', '입력은 표준입력을 사용한다. 입력은 자연수 n을 포함하는 한 줄로 구성된다. 여기서, 1 ≤ n ≤ 50,000이다.', '출력은 표준출력을 사용한다. 합이 n과 같게 되는 제곱수들의 최소 개수를 한 줄에 출력한다.', 1, 3885);
insert into problems(problem_id, problem_title, problem_content, input_condition, output_condition, problem_rank) values (1958, 'LCS 3', '문자열과 놀기를 세상에서 제일 좋아하는 영식이는 오늘도 문자열 2개의 LCS(Longest Common Subsequence)를 구하고 있었다. 어느 날 영식이는 조교들이 문자열 3개의 LCS를 구하는 것을 보았다. 영식이도 도전해 보았지만 실패하고 말았다. 이제 우리가 할 일은 다음과 같다. 영식이를 도와서 문자열 3개의 LCS를 구하는 프로그램을 작성하라.', '첫 줄에는 첫 번째 문자열이, 둘째 줄에는 두 번째 문자열이, 셋째 줄에는 세 번째 문자열이 주어진다. 각 문자열은 알파벳 소문자로 이루어져 있고, 길이는 100보다 작거나 같다.', '첫 줄에 첫 번째 문자열과 두 번째 문자열과 세 번째 문자열의 LCS의 길이를 출력한다.', 4834);
insert into problems(problem_id, problem_title, problem_content, input_condition, output_condition, problem_rank) values (21924, '도시 건설', '채완이는 신도시에 건물 사이를 잇는 양방향 도로를 만들려는 공사 계획을 세웠다. 공사 계획을 검토하면서 비용이 생각보다 많이 드는 것을 확인했다. 채완이는 공사하는 데 드는 비용을 아끼려고 한다. 모든 건물이 도로를 통해 연결되도록 최소한의 도로를 만들려고 한다. 위 그림에서 건물과 직선으로 표시된 도로, 해당 도로를 만들 때 드는 비용을 표시해놓은 지도이다. 그림에 있는 도로를 다 설치할 때 드는 비용은 62이다. 모든 건물을 연결하는 도로만 만드는 비용은 27로 절약하는 비용은 35이다. 채완이는 도로가 너무 많아 절약되는 금액을 계산하는 데 어려움을 겪고 있다. 채완이를 대신해 얼마나 절약이 되는지 계산해주자.', '첫 번째 줄에 건물의 개수 N과 도로의 개수 M이 주어진다. 두 번째 줄부터 M+1줄까지 건물의 번호 a,b 와 두 건물 사이 도로를 만들 때 드는 비용 c가 주어진다. 중복된 도로는 주어지지 않는다.', '예산을 얼마나 절약 할 수 있는지 출력한다. 만약 모든 건물이 연결되어 있지 않는다면 -1을 출력한다.',15);
insert into problems(problem_id, problem_title, problem_content, input_condition, output_condition, problem_rank) values (1600, '말이 되고픈 원숭이', '동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그 녀석은 말(Horse)이 되기를 간절히 원했다. 그래서 그는 말의 움직임을 유심히 살펴보고 그대로 따라 하기로 하였다. 말은 말이다. 말은 격자판에서 체스의 나이트와 같은 이동방식을 가진다. 다음 그림에 말의 이동방법이 나타나있다. x표시한 곳으로 말이 갈 수 있다는 뜻이다. 참고로 말은 장애물을 뛰어넘을 수 있다. 근데 원숭이는 한 가지 착각하고 있는 것이 있다. 말은 저렇게 움직일 수 있지만 원숭이는 능력이 부족해서 총 K번만 위와 같이 움직일 수 있고, 그 외에는 그냥 인접한 칸으로만 움직일 수 있다. 대각선 방향은 인접한 칸에 포함되지 않는다. 이제 원숭이는 머나먼 여행길을 떠난다. 격자판의 맨 왼쪽 위에서 시작해서 맨 오른쪽 아래까지 가야한다. 인접한 네 방향으로 한 번 움직이는 것, 말의 움직임으로 한 번 움직이는 것, 모두 한 번의 동작으로 친다. 격자판이 주어졌을 때, 원숭이가 최소한의 동작으로 시작지점에서 도착지점까지 갈 수 있는 방법을 알아내는 프로그램을 작성하시오.', '첫째 줄에 정수 K가 주어진다. 둘째 줄에 격자판의 가로길이 W, 세로길이 H가 주어진다. 그 다음 H줄에 걸쳐 W개의 숫자가 주어지는데, 0은 아무것도 없는 평지, 1은 장애물을 뜻한다. 장애물이 있는 곳으로는 이동할 수 없다. 시작점과 도착점은 항상 평지이다. W와 H는 1이상 200이하의 자연수이고, K는 0이상 30이하의 정수이다.', '첫째 줄에 원숭이의 동작수의 최솟값을 출력한다. 시작점에서 도착점까지 갈 수 없는 경우엔 -1을 출력한다.',6000);
insert into problems(problem_id, problem_title, problem_content, input_condition, output_condition, multilingual_flag ,problem_rank) values (21860, 'XorSum', 'You are given an array V, consisting of N integers V1, V2, …, VN. Your task is to find the result of XOR (1 ≤ i ≤ j ≤ N) (Vi + Vj).', 'The first line contains integer N – the size of the array. The second line contains N space-separated integers V1, V2, …, VN.', 'The first line contains the required answer.',1,512);



insert into boards(board_title, problem_id, category, board_content, writer) values ('C언어 런타임에러 load of null 질문', 8958, '질문', '이 코드에서 5번째 줄을 char arr[80];으로 바꾸기만 하면 정답이 되던데 이 코드는 왜 안되는 걸까요?', 'slygun');
insert into boards(board_title, problem_id, category, board_content, writer) values ('17626번 C 질문입니다.', 17626, '질문', '간단한 문제같은데 왜 틀리는지 모르겠네요.. 혹시 제 코드에 반례가 있나요?', 'pppp1923');
insert into boards(board_title, problem_id, category, board_content, writer) values ('어디서 틀린걸까요 ㅠ', 1958, '질문', 'dp를 두번 하는 방식으로 문제를 풀었습니다. 처음에는 a와 b를 lcs값을 구해서 a의 자리에 b의 lcs 값을 임시로 저장하고 그 값으로 dp테이블을 다시 만들었습니다. [a와 b의 lcs값, a와 c의 lcs] 으로 이뤄진 2차원 배열을 만들고 마지막에는 2차원 배열을 for문으로 탐색하면서 min값중에 최댓값을 찾았습니다. 일단 게시판의 반례들은 다 맞은듯 했습니다만, 코드를 넣으니 가차없이 틀리네요 ㅠ_ㅠ 이런 접근은 안 되는 접근일까요?', 'omh9876');
insert into boards(board_title, problem_id, category, board_content, writer) values ('조건을 수정해 주세요.', 21924, '오타/오역/요청', '"중복된 도로는 주어지지 않는다." -> "같은 쌍의 건물을 연결하는 두 도로는 주어지지 않는다." 같은 쌍의 건물을 연결해도 엄연히 서로 다른 도로입니다.', 'fantasy7772');
insert into boards(board_title, problem_id, category, board_content, writer) values ('outofbounds가 뜨는데 어떤 이유 때문일까요?', 1600, '질문', '아래 코드를 그냥 컴파일하고 수행하면 되는데, 사이트에 올리면 outofbounds가 발생합니다. 배열을 벗어나는게 없어 보이는데, 무엇이 잘 못 된건지 알 수 있을까요?', 'nickse461');